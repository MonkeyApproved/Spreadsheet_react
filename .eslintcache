[{"/Users/Janik/Homepage/React/spreadsheet2/src/index.tsx":"1","/Users/Janik/Homepage/React/spreadsheet2/src/reportWebVitals.ts":"2","/Users/Janik/Homepage/React/spreadsheet2/src/App.tsx":"3","/Users/Janik/Homepage/React/spreadsheet2/src/components/EquationInput/EquationInput.tsx":"4","/Users/Janik/Homepage/React/spreadsheet2/src/equations/equation.ts":"5","/Users/Janik/Homepage/React/spreadsheet2/src/equations/printEquation.ts":"6","/Users/Janik/Homepage/React/spreadsheet2/src/equations/computeResult.ts":"7","/Users/Janik/Homepage/React/spreadsheet2/src/equations/parseEquation.ts":"8","/Users/Janik/Homepage/React/spreadsheet2/src/equations/reversePolishNotation.ts":"9","/Users/Janik/Homepage/React/spreadsheet2/src/equations/tokenEnums.ts":"10","/Users/Janik/Homepage/React/spreadsheet2/src/equations/mathFunctions.ts":"11","/Users/Janik/Homepage/React/spreadsheet2/src/equations/tokenUtils.ts":"12","/Users/Janik/Homepage/React/spreadsheet2/src/equations/tokenCreation.ts":"13"},{"size":501,"mtime":1620300995529,"results":"14","hashOfConfig":"15"},{"size":425,"mtime":1608388666730,"results":"16","hashOfConfig":"15"},{"size":379,"mtime":1618145848871,"results":"17","hashOfConfig":"15"},{"size":736,"mtime":1620377580963,"results":"18","hashOfConfig":"15"},{"size":516,"mtime":1620295873049,"results":"19","hashOfConfig":"15"},{"size":1795,"mtime":1620384345219,"results":"20","hashOfConfig":"15"},{"size":2175,"mtime":1620304032424,"results":"21","hashOfConfig":"15"},{"size":8512,"mtime":1620384690855,"results":"22","hashOfConfig":"15"},{"size":3145,"mtime":1620378987034,"results":"23","hashOfConfig":"15"},{"size":1266,"mtime":1620385012655,"results":"24","hashOfConfig":"15"},{"size":3700,"mtime":1620297711471,"results":"25","hashOfConfig":"15"},{"size":993,"mtime":1620295465149,"results":"26","hashOfConfig":"15"},{"size":3358,"mtime":1620379121346,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"1wjaxft",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"43","messages":"44","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"30"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/Janik/Homepage/React/spreadsheet2/src/index.tsx",[],[],"/Users/Janik/Homepage/React/spreadsheet2/src/reportWebVitals.ts",[],"/Users/Janik/Homepage/React/spreadsheet2/src/App.tsx",[],"/Users/Janik/Homepage/React/spreadsheet2/src/components/EquationInput/EquationInput.tsx",[],"/Users/Janik/Homepage/React/spreadsheet2/src/equations/equation.ts",[],"/Users/Janik/Homepage/React/spreadsheet2/src/equations/printEquation.ts",[],"/Users/Janik/Homepage/React/spreadsheet2/src/equations/computeResult.ts",[],"/Users/Janik/Homepage/React/spreadsheet2/src/equations/parseEquation.ts",["56"],"import {\n  getNumberToken,\n  getOperatorToken,\n  getStringToken,\n  getCompositionToken,\n  getUnknownToken,\n  getStartToken,\n  getEndToken,\n  getCellRangeToken,\n  getFunctionToken,\n} from './tokenCreation';\nimport { CompositionType, TokenType } from './tokenEnums';\nimport { Token, StartToken, EndToken } from './tokenTypes';\nimport { computesToValue, isValue, valueNext } from './tokenUtils';\n\nexport default function getTokens(equation: string): Token[] {\n  const tokens: Token[] = parseEquation(equation);\n  return fixTokens(tokens);\n}\n\nfunction parseEquation(equation: string): Token[] {\n  // split up the expression into it's basic elements (numbers, operators, variables, brackets)\n  // all strings that are defined in mathFunctions() are treated as functions, all others are\n  // treated as variable names.\n\n  const startToken: StartToken = getStartToken();\n  const endToken: EndToken = getEndToken(equation.length);\n  const tokens: Token[] = [startToken, endToken];\n\n  // look for variables and functions\n  let leftOver = equation.replace(/[a-z]+[a-z0-9]*/gi, (match, offset) => {\n    tokens.push(getStringToken(match, offset));\n    return ' '.repeat(match.length);\n  });\n\n  // look for numbers\n  leftOver = leftOver.replace(/[0-9]+[.]?[0-9]*/g, (match, offset) => {\n    tokens.push(getNumberToken(match, offset));\n    return ' '.repeat(match.length);\n  });\n\n  // look for operators\n  leftOver = leftOver.replace(/[+*^_%/-]/g, (match, offset) => {\n    tokens.push(getOperatorToken(match, offset));\n    return ' ';\n  });\n\n  // look for brackets\n  leftOver = leftOver.replace(/[)([,:\\]]/g, (match, offset) => {\n    tokens.push(getCompositionToken(match, offset));\n    return ' ';\n  });\n\n  // look for unknown characters\n  leftOver.replace(/[^\\s]+/g, (match, offset) => {\n    tokens.push(getUnknownToken(match, offset));\n    return ' '.repeat(match.length);\n  });\n\n  tokens.sort((a, b) => a.position.offset - b.position.offset);\n  return tokens;\n}\n\ninterface EquationStats {\n  groundLevelCommas: number;\n  currentLevel: number;\n  hierarchy: Token[];\n  index: number;\n  length: number;\n}\n\nfunction fixTokens(tokens: Token[]): Token[] {\n  const tracker: EquationStats = {\n    groundLevelCommas: 0,\n    currentLevel: -1,\n    hierarchy: [],\n    index: 1,\n    length: tokens.length,\n  };\n\n  for (tracker.index = 1; tracker.index < tracker.length - 1; tracker.index++) {\n    checkForMissingMul(tokens, tracker);\n    checkForSign(tokens, tracker);\n    handleCellRange(tokens, tracker);\n    handleArrays(tokens, tracker);\n    handleParenthesis(tokens, tracker);\n    handleComma(tokens, tracker);\n    checkValidity(tokens, tracker);\n  }\n\n  checkParenthesis(tokens, tracker);\n\n  return tokens;\n}\n\nfunction checkForMissingMul(tokens: Token[], tracker: EquationStats): void {\n  const token = tokens[tracker.index];\n  const next = tokens[tracker.index + 1];\n  if (isValue(token) && valueNext(next)) {\n    // fix missing multiplication -> '2 sin(2)' or '2(1+1)' or '2 bob' or '2 A2'\n    const offset = (token.position.offset + next.position.offset) / 2;\n    const newToken = getOperatorToken('*', offset);\n    newToken.warning = 'added';\n    tokens.splice(tracker.index + 1, 0, newToken);\n    tracker.length++;\n  }\n}\n\nfunction checkForSign(tokens: Token[], tracker: EquationStats): void {\n  // check usage of '-' or '+' as sign:\n  // -1+2 or 2+(-3+5) or array(+1,-2,3)\n\n  const token = tokens[tracker.index];\n  // check if current token is plus or minus operator\n  if (token.type !== TokenType.Operator) return;\n  if (['-', '+'].indexOf(token.symbol) === -1) return;\n\n  // check that next token is some sort of value\n  if (!computesToValue(tokens[tracker.index + 1])) return;\n\n  // check that previous token indicates that the operator should be a sign\n  let isSign = false;\n  const previous = tokens[tracker.index - 1];\n  if (previous.type === TokenType.Operator) {\n    if (['^', '*', '_', '/'].indexOf(previous.symbol) !== -1) {\n      isSign = true;\n    }\n  } else if (previous.type === TokenType.Composition) {\n    if (['(', '[', ','].indexOf(previous.symbol) !== -1) {\n      isSign = true;\n    }\n  } else if (previous.type === TokenType.Start) {\n    isSign = true;\n  }\n\n  // if operator is a sign, remove plus signs and replace minus operator with \"negative\" operator\n  if (isSign) {\n    if (token.symbol === '+') {\n      // remove plus sign (not needed)\n      tokens.splice(tracker.index, 1);\n      tracker.index;\n      tracker.length--;\n    } else {\n      tokens.splice(tracker.index, 1, getOperatorToken('negative', token.position.offset));\n    }\n  }\n}\n\nfunction handleCellRange(tokens: Token[], tracker: EquationStats): void {\n  const token = tokens[tracker.index];\n  // check if token is a colon (used to indicate cell ranges, e.g. A1:E4)\n  if (token.type !== TokenType.Composition) return;\n  if (token.name !== CompositionType.Colon) return;\n\n  // before and after colon there must be cell tokens\n  const previous = tokens[tracker.index - 1];\n  const next = tokens[tracker.index + 1];\n  if (previous.type === TokenType.Cell && next.type === TokenType.Cell) {\n    const cellRange = getCellRangeToken(previous, next);\n    tokens.splice(tracker.index - 1, 3, cellRange);\n    tracker.index--;\n    tracker.length -= 2;\n  } else {\n    // invalid use of colon\n    token.error = 'misplaced colon';\n  }\n}\n\nfunction handleArrays(tokens: Token[], tracker: EquationStats): void {\n  const token = tokens[tracker.index];\n  if (token.type !== TokenType.Composition) return;\n\n  if (token.name === CompositionType.ArrayStart) {\n    const arrayFunction = getFunctionToken('array', token.position.offset);\n    const leftParenthesis = getCompositionToken('(', token.position.offset + 0.5);\n    tokens.splice(tracker.index, 1, arrayFunction, leftParenthesis);\n    tracker.length++;\n    tracker.index++;\n    tracker.currentLevel++;\n    tracker.hierarchy.push(token);\n    return;\n  }\n\n  if (token.name === CompositionType.ArrayEnd) {\n    if (tracker.currentLevel === -1) {\n      token.error = 'opening array missing';\n      return;\n    }\n\n    const reference = tracker.hierarchy.pop();\n    tracker.currentLevel--;\n    // check if corresponding token was \"open array\"\n    if (reference?.type !== TokenType.Function || reference.name !== 'array') {\n      token.error = 'no matching open array found';\n      return;\n    }\n\n    // replace with parenthesis\n    const rightParenthesis = getCompositionToken(')', token.position.offset);\n    tokens.splice(tracker.index, 1, rightParenthesis);\n  }\n}\n\nfunction handleParenthesis(tokens: Token[], tracker: EquationStats): void {\n  const token = tokens[tracker.index];\n  if (token.type !== TokenType.Composition) return;\n\n  if (token.name === CompositionType.LeftParenthesis) {\n    const previous = tokens[tracker.index - 1];\n    tracker.hierarchy.push(previous.type === TokenType.Function ? previous : token);\n    tracker.currentLevel++;\n    return;\n  }\n\n  if (token.name === CompositionType.RightParenthesis) {\n    if (tracker.currentLevel === -1) {\n      token.error = 'opening parenthesis missing';\n      return;\n    }\n\n    tracker.currentLevel--;\n    tracker.hierarchy.pop();\n  }\n}\n\nfunction handleComma(tokens: Token[], tracker: EquationStats): void {\n  const token = tokens[tracker.index];\n  if (token.type !== TokenType.Composition || token.name !== CompositionType.Comma) return;\n\n  if (tracker.currentLevel === -1) {\n    // commas on ground level are interpreted as an array, 1,2,3 -> [1,2,3]\n    tracker.groundLevelCommas++;\n    return;\n  }\n  const reference = tracker.hierarchy[tracker.currentLevel];\n  if (reference.type === TokenType.Function) {\n    reference.nArgs++;\n  }\n}\n\nfunction checkValidity(tokens: Token[], tracker: EquationStats): void {\n  const token = tokens[tracker.index];\n  const next = tokens[tracker.index + 1];\n  if\n}\n\nfunction checkParenthesis(tokens: Token[], tracker: EquationStats): void {\n  if (tracker.currentLevel < -1) {\n    tokens[0].error = 'missing opening parenthesis';\n    return;\n  }\n\n  if (tracker.currentLevel > -1) {\n    tokens[0].error = 'missing closing parenthesis';\n    return;\n  }\n\n  if (tracker.groundLevelCommas === 0) return;\n\n  const arrayFunction = getFunctionToken('array', 0.1);\n  arrayFunction.nArgs = tracker.groundLevelCommas + 1;\n  const leftParenthesis = getCompositionToken('(', 0.2);\n  const maxOffset = tokens[tokens.length - 1].position.offset;\n  const rightParenthesis = getCompositionToken(')', maxOffset + 1);\n  tokens.splice(1, 0, arrayFunction, leftParenthesis);\n  tokens.splice(tokens.length - 1, 0, rightParenthesis);\n}\n","/Users/Janik/Homepage/React/spreadsheet2/src/equations/reversePolishNotation.ts",[],"/Users/Janik/Homepage/React/spreadsheet2/src/equations/tokenEnums.ts",[],"/Users/Janik/Homepage/React/spreadsheet2/src/equations/mathFunctions.ts",[],"/Users/Janik/Homepage/React/spreadsheet2/src/equations/tokenUtils.ts",[],"/Users/Janik/Homepage/React/spreadsheet2/src/equations/tokenCreation.ts",[],{"ruleId":null,"fatal":true,"severity":2,"message":"57","line":245,"column":0},"Parsing error: '(' expected."]